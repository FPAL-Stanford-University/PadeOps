module GaborModeRoutines
  ! This module is used to program the initialization of Gabor mode attributes
  ! (e.g. uhat, kx, etc.) without committing to an OOP paradigm. Will port this
  ! as need-be to the GaborMode and GaborModePop classes
  use kind_parameters, only: rkind
  use domainSetup, only: getStartAndEndIndices, gpQHcent, kmin, kmax, dxQH, &
    dyQH, dzQH, xQHedge, yQHedge, zQHedge, finishDomainSetup
  use constants, only: pi
  use decomp_2D, only: nrank, nproc
  use mpi
  use fortran_assert, only: assert
  implicit none

  ! Complex vector amplitudes
  real(rkind), dimension(:), allocatable :: uhatR, uhatI, vhatR, vhatI, whatR, whatI
  real(rkind), dimension(:,:,:,:,:), allocatable, private :: uR, uI, vR, vI, wR, wI

  ! Wave-vector components
  real(rkind), dimension(:), allocatable :: kx, ky, kz
  real(rkind), dimension(:,:,:,:,:), allocatable, private :: k1, k2, k3

  ! Physical locatin of Gabor modes
  real(rkind), dimension(:), allocatable :: gmxloc, gmyloc, gmzloc
  real(rkind), dimension(:,:,:,:), allocatable, private :: gmx, gmy, gmz

  ! Misc variables
  integer :: nmodes
  integer, dimension(:), allocatable :: nmodesALL

  ! Problem parameters
  integer :: nk, ntheta
  real(rkind) :: scalefact, ctau, Anu = 1.d-4

  ! Warning handling
  logical, private :: doWarning = .true.
  logical, private :: modeMemoryInitialized = .false., isotropicModesInitialized = .false.
  logical, private :: finishModeInitialization = .false. ! <-- After straining procedure

  ! Array dimensions for the particular MPI partition
  integer, private :: isz, jsz, ksz

  contains

    subroutine initializeModes(inputfile)
      use domainSetup
      character(len=*), intent(in) :: inputfile
      integer :: ierr, ioUnit
      namelist /GABOR/ nk, ntheta, scalefact, ctau, Anu

      ! Verify that the domain has been setup
      call assert(finishDomainSetup,'Attempting to initialize Gabor modes '//&
        'without setting up domain first.')
      
      ! Read inputfile
      open(unit=ioUnit, file=trim(inputfile), form='FORMATTED', iostat=ierr)
      read(unit=ioUnit, NML=GABOR)
      close(ioUnit)

      call allocateMemory()
      modeMemoryInitialized = .true.
    end subroutine

    subroutine allocateMemory()
      integer :: ist, ien, jst, jen, kst, ken

      call getStartAndEndIndices(gpQHcent,ist,ien,jst,jen,kst,ken,isz,jsz,ksz)
      
      ! ND arrays
      allocate(uR(isz,jsz,ksz,nk,ntheta), uI(isz,jsz,ksz,nk,ntheta))
      allocate(vR(isz,jsz,ksz,nk,ntheta), vI(isz,jsz,ksz,nk,ntheta))
      allocate(wR(isz,jsz,ksz,nk,ntheta), wI(isz,jsz,ksz,nk,ntheta))

      allocate(k1(isz,jsz,ksz,nk,ntheta))
      allocate(k2(isz,jsz,ksz,nk,ntheta))
      allocate(k3(isz,jsz,ksz,nk,ntheta))

      allocate(gmx(isz,jsz,ksz,nk*ntheta))
      allocate(gmy(isz,jsz,ksz,nk*ntheta))
      allocate(gmz(isz,jsz,ksz,nk*ntheta))
      
      ! Allocate memory for 1D vectors
      nmodes = isz*jsz*ksz*nk*ntheta
      allocate(uhatR(nmodes), uhatI(nmodes))
      allocate(vhatR(nmodes), vhatI(nmodes))
      allocate(whatR(nmodes), whatI(nmodes))

      allocate(kx(nmodes), ky(nmodes), kz(nmodes))

      allocate(gmxloc(nmodes), gmyloc(nmodes), gmzloc(nmodes))
    end subroutine

    subroutine generateIsotropicModes()
      use gridtools, only: logspace
      use largeScalesMod, only: KE, L, computeLrgSclQOIs
      use random, only: uniform_random
      integer :: i, j, k, kid, thetaID
      real(rkind), dimension(nk+1) :: kedge
      real(rkind), dimension(nk) :: kmag, dk
      integer :: ierr
      real(rkind), dimension(nk*ntheta) :: rand1
      real(rkind), dimension(ntheta) :: theta, kztemp, r
      real(rkind), dimension(nk) :: E
      real(rkind), dimension(isz,jsz,ksz,nk,ntheta), allocatable :: umag, thetaVel
      real(rkind), dimension(isz,jsz,ksz,nk,ntheta), allocatable :: uRmag, uImag, rand1
      real(rkind), dimension(isz,jsz,ksz,nk,ntheta), allocatable :: p1x, p1y, p1z
      real(rkind), dimension(isz,jsz,ksz,nk,ntheta), allocatable :: p2x, p2y, p2z
      real(rkind), dimension(isz,jsz,ksz,nk,ntheta), allocatable :: orientationX, &
                                                                    orientationY, &
                                                                    orientationZ
      integer :: seed1=1, seed2=2, seed3=3, seed4=4, seed5=5, seed6=6, seed7=7
      real(rkind) :: xmin, ymin, zmin


      ! First make sure we have the large scale info we need
      call assert(computeLrgSclQOIs,"Can't initialize Gabor modes w/o "//&
        "large scale quantities")

      ! Confirm we have allocated the required memory
      call assert(modeMemoryInitialized,"Gabor mode memory not allocated")
        
      ! Allocate memory for ND arrays
      allocate(umag(isz,jsz,ksz,nk,ntheta))
      allocate(uRmag(isz,jsz,ksz,nk,ntheta))
      allocate(uImag(isz,jsz,ksz,nk,ntheta))
      allocate(rand1(isz,jsz,ksz,nk,ntheta))
      allocate(thetaVel(isz,jsz,ksz,nk,ntheta))

      allocate(p1x(isz,jsz,ksz,nk,ntheta))
      allocate(p1y(isz,jsz,ksz,nk,ntheta))
      allocate(p1z(isz,jsz,ksz,nk,ntheta))

      allocate(p2x(isz,jsz,ksz,nk,ntheta))
      allocate(p2y(isz,jsz,ksz,nk,ntheta))
      allocate(p2z(isz,jsz,ksz,nk,ntheta))

      allocate(orientationX(isz,jsz,ksz,nk,ntheta))
      allocate(orientationY(isz,jsz,ksz,nk,ntheta))
      allocate(orientationZ(isz,jsz,ksz,nk,ntheta))
      
      ! Send the number of modes on each partition
      allocate(nmodesALL(nproc))
      call MPI_Allgather(nmodes,1,MPI_INTEGER,nmodesALL,1,MPI_INTEGER,MPI_COMM_WORLD,ierr)

      ! Assign wave-vector magnitudes based on logarithmically spaced shells
      ! (non-dimensionalized with L)
      !kedge = logspace(kmin,kmax,nk+1)
      kedge = logspace(log10(kmin),log10(kmax),nk+1)
      kmag = 0.5d0*(kedge(1:nk) + kedge(2:nk+1))
      dk = kedge(2:nk+1) - kedge(1:nk)
print*, "kmin,kmax :", kmin, ",", kmax
print*, "maxval(kedge) = ", maxval(kedge)
print*, "kedge = ", kedge
print*, "nk = ", nk
print*, "size(kedge) = ", size(kedge)
print*, "size(rand1) = ", size(rand1)
      do k = 1,ksz
        zmin = zQHedge(k)
        do j = 1,jsz
          ymin = yQHedge(j)
          do i = 1,isz
            xmin = xQHedge(i)

            ! Uniformily distribute modes in QH region
            call uniform_random(rand1,0.d0,1.d0,seed1)
            gmx(i,j,k,:) = xmin + dxQH*rand1
            
            call uniform_random(rand1,0.d0,1.d0,seed2)
            gmy(i,j,k,:) = ymin + dyQH*rand1

            call uniform_random(rand1,0.d0,1.d0,seed3)
            gmz(i,j,k,:) = zmin + dzQH*rand1

            do kid = 1,nk
              ! Isotropically sample wave-vector components
              call uniform_random(theta,0.d0,2.d0*pi,seed4)
              call uniform_random(kztemp,-1.d0,1.d0,seed5)

              ! Assign wave-vector components
              k3(i,j,k,kid,:) = kmag(kid)*kztemp
              r = sqrt(1.d0 - kztemp*kztemp)
              k1(i,j,k,kid,:) = kmag(kid)*r*cos(theta)
              k2(i,j,k,kid,:) = kmag(kid)*r*sin(theta)
            end do

            ! Non-dimensional model energy spectrum
            E = getModelSpectrum(kmag,KE(i,j,k),L(i,j,k),nk)

            ! Amplitude of each mode such that the sum of mode amplitudes gives
            ! the correct kinetic energy
            umag(i,j,k,:,1) = sqrt(2*E*dk/ntheta)
          end do
        end do
      end do
print*, "maxval(umag) = ", maxval(umag) ! DEBUG
print*, "maxval(E) = ", maxval(E) ! DEBUG
print*, "maxval(KE) = ", maxval(KE)
print*, "maxval(L) = ", maxval(L)
      ! Replicate array to match array dimensions for multiplication below
      do thetaID = 2,ntheta
        umag(:,:,:,:,thetaID) = umag(:,:,:,:,1)
      end do

      ! Get velocity vector orientations
        ! Generate basis of tangent plane to wavenumber shell
        p1x = 0.d0
        p1y = -k3
        p1z = k2

        p2x = k2*k2 + k3*k3
        p2y = -k1*k2
        p2z = -k1*k3

        call normalizeVec(p1x,p1y,p1z)
        call normalizeVec(p2x,p2y,p2z)

        ! Assign orientation of the velocity vectors
        call uniform_random(thetaVel,0.d0,2.d0*pi,seed6)
        orientationX = cos(thetaVel)*p1x + sin(thetaVel)*p2x
        orientationY = cos(thetaVel)*p1y + sin(thetaVel)*p2y
        orientationZ = cos(thetaVel)*p1z + sin(thetaVel)*p2z

      ! We have the modulus and orientation of the complex-valued amplitudes.
      ! Now assing the real and imaginary components
        call uniform_random(rand1,0.d0,1.d0,seed7)
        uRmag = rand1*umag
        uImag = sqrt(umag*umag - uRmag*uRmag)

        uR = uRmag*orientationX
        uI = uImag*orientationX

        vR = uRmag*orientationY
        vI = uImag*orientationY

        wR = uRmag*orientationZ
        wI = uImag*orientationZ
      
      call assert(maxval(uR) > 0.d0, 'uR is 0')
      call assert(maxval(uI) > 0.d0, 'uI is 0')
      call assert(maxval(vR) > 0.d0, 'vR is 0')
      call assert(maxval(vI) > 0.d0, 'vI is 0')
      call assert(maxval(wR) > 0.d0, 'wR is 0')
      call assert(maxval(wI) > 0.d0, 'wI is 0')


      ! Collapse the Gabor mode data into a 1D vector
      uhatR = reshape(uR,(/nmodes/)); uhatI = reshape(uI,(/nmodes/))
      vhatR = reshape(vR,(/nmodes/)); vhatI = reshape(vI,(/nmodes/))
      whatR = reshape(wR,(/nmodes/)); whatI = reshape(wI,(/nmodes/))

      kx = reshape(k1,(/nmodes/))
      ky = reshape(k2,(/nmodes/))
      kz = reshape(k3,(/nmodes/))

      gmxloc = reshape(gmx,(/nmodes/))
      gmyloc = reshape(gmy,(/nmodes/))
      gmzloc = reshape(gmz,(/nmodes/))

      ! Deallocate memory for ND arrays
      deallocate(umag,thetaVel)
      deallocate(uRmag,uImag,rand1)
      deallocate(p1x,p1y,p1z,p2x,p2y,p2z)
      deallocate(orientationX,orientationY,orientationZ)

      ! Reset warning trigger
      doWarning = .true.

      ! Acknowledge that isotropic modes are initialized
      isotropicModesInitialized = .true.
    end subroutine

    subroutine finalizeGaborModes()
      if (allocated(uhatR)) deallocate(uhatR)
      if (allocated(uhatI)) deallocate(uhatI)
      if (allocated(vhatR)) deallocate(vhatR)
      if (allocated(vhatI)) deallocate(vhatI)
      if (allocated(whatR)) deallocate(whatR)
      if (allocated(whatI)) deallocate(whatI)

      if (allocated(uR)) deallocate(uR)
      if (allocated(uI)) deallocate(uI)
      if (allocated(vR)) deallocate(vR)
      if (allocated(vI)) deallocate(vI)
      if (allocated(wR)) deallocate(wR)
      if (allocated(wI)) deallocate(wI)

      if (allocated(kx)) deallocate(kx)
      if (allocated(ky)) deallocate(ky)
      if (allocated(kz)) deallocate(kz)

      if (allocated(k1)) deallocate(k1)
      if (allocated(k2)) deallocate(k2)
      if (allocated(k3)) deallocate(k3)

      if (allocated(gmxloc)) deallocate(gmxloc)
      if (allocated(gmyloc)) deallocate(gmyloc)
      if (allocated(gmzloc)) deallocate(gmzloc)

      if (allocated(gmx)) deallocate(gmx)
      if (allocated(gmy)) deallocate(gmy)
      if (allocated(gmz)) deallocate(gmz)

      if (allocated(nmodesALL)) deallocate(nmodesALL)
    end subroutine

    function getModelSpectrum(k,KE,L,nk) result(E) 
      use exits, only: warning
      real(rkind), dimension(:), intent(in) :: k
      integer, intent(in) :: nk
      real(rkind), dimension(nk) :: kL, fL, feta
      real(rkind), intent(in) :: KE, L
      real(rkind) :: C
      real(rkind), dimension(nk) :: E

      ! Non-dimensional wavenumber
      kL = k*L

      ! Model coefficient chosen such that the integrated spectrum equals total
      ! kinetic energy
      C = 0.4843d0

      ! Energetic scalse
      fL = kL**4.d0/(1.d0 + kL*kL)**(17.d0/6.d0)

      ! Dissipative scales
      feta = 1.d0
      if (doWarning) then
        call warning("Finite Re model spectrum is not implemented")
        doWarning = .false.
      end if

      ! Model spectrum
      E = C*2.d0*KE*L*fL*feta
    end function

    pure subroutine normalizeVec(x,y,z)
      real(rkind), dimension(:,:,:,:,:), intent(inout) :: x, y, z
      real(rkind), dimension(size(x,1),size(x,2),size(x,3),size(x,4),size(x,5)) :: mag
    
      mag = sqrt(x*x + y*y + z*z)
      x = x/mag
      y = y/mag
      z = z/mag
    end subroutine

end module
